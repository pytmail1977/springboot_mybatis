2018-11-03
1.在DbService上
	@Service("DbService")
	改为
	@Repository("DbService")
2.在CoreServiceImpl上
	@Service("CoreService") 
	改为
	@Service("Normal") 
3.在CoreController上
    @Autowired
    下，添加
    @Qualifier("JHSBC")
4.在CoreController上
	private CoreServiceImplJHSBC jhsbcService;
	改回
	private CoreService coreService;
	
	String respMessage = jhsbcService.processRequest(req);
	改回
	String respMessage = coreService.processRequest(req);
5.去掉CoreServiceImpl中的@Autowired
6.去掉CoreServiceImplJHSBC中的@Autowired
7.工程（右键）-》Run as-》Maven install
	成功生成target/springboot_mybatis-0.0.1-SNAPSHOT.jar
8.jar包不易部署，在pom.xml改jar为war
9.针对易地部署根据（https://blog.csdn.net/soldier_123/article/details/78917227）要排除springboot集成的tomcat“spring-boot-starter-tomcat”。有两种方法啊，暂时都未使用。
10.增加一个包testService
11.在包testService中增加一个接口类ITestService。
12.增加一个对接口类ITestService的实现TestService。
13.在控制组件CoreController中增加对接口ITestService的注入。并仿照post增加一个方法postTest，调用testService.processRequest处理
14.为了打包到深信服服务器（tomcat使用80端口），打包时修改配置application.properties当中配置的端口server.port=8080，由8080改为80。（打包完成后需要改回来）

2018-11-04
1.maven clean之后，maven install，再次出现找不到
	o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in
	发现问题在于新建State类的时候，不当使用了@Autowired，去掉后问题消失，再次maven install，又再次出现
先继续写
1.完善State类
	增加两个属性
		private String strComment; //上下文描述
		private int intDepeth; //上下文深度
	增加setter和getter
2.完善StateStack类
	增加一个返回当前上下文提示字符串的方法context()
3.修改CoreServiceImplJHSBC，根据用户微信号查询User表，如果没有结果就插入一条记录。
4.在DbService中加入一个函数insertNewUser，插入一条新的用户记录
5.修改CoreController，之后可以在http://localhost:8080/hello,http://localhost:8080/test中正确得到返回，而且本地微信调试，修改服务器地址url，通过token验证
	（1）@RequestMapping(value = "core"
		-》
		@RequestMapping(value = ""
	（2）@RequestMapping(value = "test",method = RequestMethod.POST)
		-》
		@RequestMapping("/test")
	（3）@RequestMapping("/")
		->
		@RequestMapping("/hello")
6.修改StateStack，将top初始值从-1改为0，并修改相应的边界条件。
7.CoreServiceImplJHSBC的成员textMessageUtil必须使用@Autowired注入
	@Autowired
	private TextMessageUtil textMessageUtil;	
	否则，会报textMessageUtil是空指针
8.CoreServiceImpl的成员textMessageUtil也必须使用@Autowired注入
9.maven install 未报错
10.maven clean之后再maven install 还是报错

2018-11-07
1.修改StateStack
	将方法context改名为getContext。
	新增getCurrentState方法，取当前的状态
	
2018-11-09
1.将测试过的状态转移/函数指针工程testFuncPointer中的有关类Func、FuncBase、StateTransfer加入到工程里来，工程本身尚未使用这些类

2.去掉对图像、音频、连接等处理，统一在前面作为非文本消息回复无法处理
3.将Const类的属性都改为static，使用中不再进行实例化
4.修改
	（1）将变量
			state
		改为
			stepOfNewProj
	（2）将
			String respContent = "小牛处理请求异常，请稍候再试！";
		改为
			String respContent = "";
		挪到try的外面
	（3）在
			catch (……)
		下加入
			respContent = "小牛处理请求异常，请稍候再试！";
	（4）将变量
			map
		改为
			mapProjInfo
	（5）将
			int idUser = db.insertNewUser(newUser);
		改为
			db.insertNewUser(newUser);
			idUser  = newUser.getId_User();
	（6）将插入状态栈首个状态的操作，改到取得用户idUser之后
	（7）将变量
			stack
		改为
			stateStack
	（8）将
			如果获取用户idUser成功，就记录到状态栈中
			if (0 != idUser) {
		改为
			如果获取用户idUser成功，且状态栈为空，就记录到状态栈中
			if (0 != idUser && stateStack.sizeof() == 0) {
	（9）将
			respContent = "无法处理您发送的非文本消息！";
		改为
			respContent += "无法处理您发送的非文本消息！";
2018-11-11
1.定义枚举类型状态类StateType，替换状态转移表中的String类型。
	public enum StateType {
		/**
		 * 根据数据库整理各对象的层次关系
		 * 属于用户的有Struct、Type、Project
		 * 	属于Project的有Func、Var（全局变量）
		 * 		属于Func的有FuncStatement
		 * 		属于Func的有FuncVar（局部变量）
		 * 		   属于FuncVar的有FuncVarItem
		 * 		属于Var的有VarItem
		 * 属于Struct的有StructItem
		 * 		
		 */
		STUser,
			STStruct,
				STStructItem,
			STType,
			STProject,	
				STFunc,
					STFuncStatement,
					STFuncVar,
						STFuncVarItem,
				STVar,
					STVarItem,
	}
2.修改State类，增加一个stateType，说明这个状态属于那类，比如project就是一类。然后状态转移表以状态类组织，用户进入一个project。不管这个project具体是谁，都属于状态类TypeProject，根据这个状态类决定可以转到那个状态
	private StateType stateType;//状态所属类型,并在构造函数中初始化
3.在FuncBase中增加方法：
	（1）list方法
			public static State newItem(State state, String str1, String str2) {
	（2）
 方法
			public static State add(State state, String str1, String str2) {
	（3）del方法
			public static State del(State state, String str1, String str2) {
3.修改StateTranfer
	（1）将
				private HashMap<String, HashMap<String ,Func<State,String,String> > > stateMap = new HashMap<String ,HashMap<String ,Func<State,String,String> > >();
		改为
				private HashMap<StateType, HashMap<String ,Func<State,String,String> > > stateMap = new HashMap<StateType ,HashMap<String ,Func<State,String,String> > >();
	（2）将原有用于测试的初始化状态转移表stateMap的操作全部注释掉
	
	（3）新增有关StateType.TUser状态出发的转移出口，包括cd/list/add/de
			//2018-11-11
			//新增StateType.STUser状态的转移出口cd（可进StateType.STProject，可进StateType.STVar，可进StateType.STFunc，可进StateType.STStruct，可进StateType.STType。根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTUserCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STUser, transferMapSTUserCd);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口list（可列出Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STUser, transferMapSTUserLs);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口add（可新增Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STUser, transferMapSTUserAdd);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口del（可删除Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserDel.put("del", FuncBase::del);
			stateMap.put(StateType.STUser, transferMapSTUserDel);
	（4）新增有关从StateType.TProject状态出发可做的转移
			//2018-11-11
			//新增StateType.STProject状态的转移出口cd（可进StateType.STProject，可进StateType.STVar，可进StateType.STFunc，可进根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTProjectCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STProject, transferMapSTProjectCd);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口list（可列出Project所属的Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STProject, transferMapSTProjectLs);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口add（可新增Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STProject, transferMapSTProjectAdd);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口del（可删除Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectDel.put("del", FuncBase::del);
			stateMap.put(StateType.STProject, transferMapSTProjectDel);
				
			//2018-11-11
			//新增StateType.STProject状态的转移出口dc（可退至StateType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTProjectDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectDc.put("dc", FuncBase::dc);
			stateMap.put(StateType.STProject, transferMapSTProjectDc);
	（5）初始化StateType.STFunc状态的转移出口,包括cd/dc/list/add/del
			//2018-11-11
			//新增StateType.STFunc状态的转移出口cd（可进StateType.STFunc，可进StateType.STVar，可进StateType.STFunc，可进根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTFuncCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STFunc, transferMapSTFuncCd);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口list（可列出Project所属的Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STFunc, transferMapSTFuncLs);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口add（可新增Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STFunc, transferMapSTFuncAdd);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口del（可删除Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncDel.put("del", FuncBase::del);
			stateMap.put(StateType.STFunc, transferMapSTFuncDel);
				
			//2018-11-11
			//新增StateType.STFunc状态的转移出口dc（可退至StateType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTFuncDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncDc.put("dc", FuncBase::dc);
			stateMap.put(StateType.STFunc, transferMapSTFuncDc);
	（7）初始化StateType.STFuncStatement状态的转移出口,包括dc/vi/more
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口vi（可编辑当前行、Func根据第一个参数arg1决定此行的新内容，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementVi = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementVi.put("vi", FuncBase::vi);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementVi);
			
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口more（可显示当前行，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementMore = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementMore.put("more", FuncBase::more);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementMore);
			
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口dc（可退至SceneType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementDc.put("dc", FuncBase::dc);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementDc);		
			
2018-11-12
1.将枚举类型StateType修改为SceneType
2.备份StateTransfer.java，完全清空其中初始化状态转移表的内容。

2018-11-17
1.在枚举类型定义中，增加注释信息
	STUser, //help,pwd,attr,lsp,lst,lss,cdp,cdt,cds,addp,addt,adds,delp,delt,dels
		STStruct,//help,pwd,attr,lssi(ls),cdsi(cd),addsi(add),delsi(del),dc
			STStructItem,//help,pwd,attr,dc
		STType,//help,pwd,attr,dc
		STProject,	//help,pwd,attr,lsf,lsv,cdf,cdv,addf,addv,delf,delv,dc
			STFunc, //help,pwd,attr,lsfs,lsfv,cdfs,cdfv,addfs,addfv,delfs,delfv,dc
				STFuncStatement,//help,pwd,attr,dc
				STFuncVar,//help,pwd,attr,lsfvi(ls),cdfvi(cd),addfvi(add),delfvi(del),dc
					STFuncVarItem,//help,pwd,attr,dc
			STVar,//help,pwd,attr,lsvi(ls),cdvi(cd),addvi(add),delvi(del),dc
				STVarItem,//help,pwd,attr,dc
2.修改Const.java，
	(1)新增各场景下的help信息字符串
	public static final String STUser_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lsp-列出所有project\n"
			+ "lst-列出所有type\n"
			+ "lss-列出所有struct\n"
			+ "cdp id/name-进入指定的project\n"
			+ "cdt id/name-进入指定的type\n"
			+ "cds id/name-进入指定的struct\n"
			+ "addp name-新增一个project\n"
			+ "addt name-新增一个type\n"
			+ "adds name-新增一个struct\n"
			+ "delp id-删除一个project\n"
			+ "delt id-删除一个type\n"
			+ "dels id-删除一个struct";
	public static final String STStruct_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lssi(ls)-列出struct item\n"
			+ "cdsi(cd) id-进入struct item\n"
			+ "addsi(add) type name-新增struct item\n"
			+ "delsi(del) id-删除struct item\n"
			+ "dc-退回到上一层";
		public static final String STStructItem_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "dc-退回到上一层";
	public static final String STType_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "dc-退回到上一层";
	public static final String STProject_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lsf-列出function\n"
			+ "lsv-列出全局变量var\n"
			+ "cdf id/name-进入function\n"
			+ "cdv id/name-进入var\n"
			+ "addf name-新增function\n"
			+ "addv name-新增var\n"
			+ "delf id-删除function\n"
			+ "delv id-删除var\n"
			+ "dc-退回到上一层";
		public static final String STFunc_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "lsfs-列出函数语句function statement\n"
				+ "lsfv-列出函数局部变量fuction var\n"
				+ "cdfs id-进入指定的函数语句function statement\n"
				+ "cdfv id-进入指定的函数局部变量fuction var\n"
				+ "addfs content\n-增加一条函数语句function statement"
				+ "addfv name-增加一个函数局部变量fuction var\n"
				+ "delfs id-删除一条函数语句function statement\n"
				+ "delfv id-删除一个函数局部变量fuction var\n"
				+ "dc-退回到上一层";
			public static final String STFuncStatement_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "dc-退回到上一层";
			public static final String STFuncVar_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "lsfvi(ls)-列出函数局部变量字段Function Var Item\n"
					+ "cdfvi(cd)-进入函数局部变量字段Function Var Item\n"
					+ "addfvi(add)-新增函数局部变量字段Function Var Item\n"
					+ "delfvi(del)-删除函数局部变量字段Function Var Item\n"
					+ "dc-退回到上一层";
				public static final String STFuncVarItem_HELP = "可用的命令：\n"
						+ "help-列出此帮助信息\n"
						+ "pwd-显示当前所处的场景\n"
						+ "whoami-显示当前操作的对象\n"
						+ "attr key value-修改当前对象的属性\n"
						+ "dc-退回到上一层";
		public static final String STVar_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "lsvi(ls)-列出全局变量字段Var Item\n"
				+ "cdvi(cd)-进入全局变量字段Var Item\n"
				+ "addvi(add)-新增全局变量字段Var Item\n"
				+ "delvi(del)-删除全局变量字段Var Item\n"
				+ "dc-退回到上一层";
			public static final String STVarItem_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "dc-退回到上一层";
	(2)	新增一个map，用于查询在不同的场景下应当显示什么帮助内容
	public static final Map<SceneType, String> mapHelpInfo = new HashMap<SceneType, String>(){{
			put(SceneType.STUser, STUser_HELP);
			put(SceneType.STStruct, STStruct_HELP);
			put(SceneType.STStructItem, STStructItem_HELP);
			put(SceneType.STType, STType_HELP);
			put(SceneType.STProject, STProject_HELP);
			put(SceneType.STFunc, STFunc_HELP);
			put(SceneType.STFuncStatement, STFuncStatement_HELP);
			put(SceneType.STFuncVar, STFuncVar_HELP);
			put(SceneType.STFuncVarItem, STFuncVarItem_HELP);
			put(SceneType.STVar, STVar_HELP);
			put(SceneType.STVarItem, STVarItem_HELP);
	}};
	
2.修改State类的定义，增加两项，分别是最近的用户输入，和最近给用户的输出。
	private String reqContent;
	private String respContent;
3.修改StateTransfer类
	（1）修改transferState()函数，在参数中，增加一项String reqContent，在调用
			nextState = func.apply(nowState,strArg1, strArg2);
		之前，增加对nowState的reqContent属性的设置
			nowState.setReqContent(reqContent);
	（2）注释掉构造函数public StateTransfer(State nowState)中2018-11-12和2018-11-11新增的所有内容
	（3）新增一个状态转移help
4.修改CoreServiceImplJHSBC
	（1）修改调用transferState（）函数的函数CoreServiceImp.StateProccedue()，传入reqContent参数
	（2）修改注释“进入状态机处理”处的代码，增加对StateProccedue的调用
4.修改FuncBase
	（1）将原有函数全部注释掉
	（2）根据场景枚举类型SeceneType中的注释，进行函数定义
	（3）并将attr、pwd、help、dc、whoami五个函数作为统一定义的函数
	（4）完成help函数，根据当前状态所属场景从Const类的mapHelpInfo中查找对应的help字符串，设置到当前状态state的的respContent中

2018-11-18
1.将StateService.java移入bk目录
2.修改CoreServiceImplJHSBC.java
	（1）进行stateTransfer的初始化，将
			//获取用户idUser成功后，如果是首次登录（状态栈为空），就记录到状态栈中,
    		if (stateStack.sizeof() == 0) {
    			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
    			stateStack.push(state);
    （2）将StateProccedue（）中的
    	    String strArg1 = strArray[1];
			String strArg2 = strArray[2];
    	改为
    		String strArg1 = (strArray.length>1?strArray[1]:null);
			String strArg2 = (strArray.length>2?strArray[2]:null);
3.修改StateTransfer.java
	（1）将transferState（）中的
		Func<State,String,String> func = stateMap.get(this.nowState).get(strOrder);
		改为
		Func<State,String,String> func = stateMap.get(this.nowState.getSceneType()).get(strOrder);  			
    		}

#commit #

2018-11-18/2
1.修改Func.java
	将
		public State apply(S s, T1 t1, T2 t2);
	改为
		public String apply(S s, T1 t1, T2 t2);
2.修改FuncBase.java
	将处理函数的形式由
		public static State del(State state, String str1, String str2) {
	改为
		public static String del(StateStack stateStack, String str1, String str2) {
3.删除移入bk的StateService.java和StateTransfer.java
4.新建一个StateService
	（1）将StateTransfer和StateStack作为它的成员变量
	（2）新建方法，根据用户名查询数据库是否有这个用户，对新用户做插表操作，并初始化stateStack和stateTransfer
			public String StateServiceOnUserLogin(String fromUserName) 
	（3）修改StateProccedue，直接从stateTransfer.transferState（）的返回值获取应当返回用户的提示语
5.修改StateTransfer
	（1）将
			Func<State,String,String>
		修改为
			Func<StateStack,String,String>
	（2）取消StateTransfer中的属性nowState
		取消构造函数中对nowState的初始化
	（3）取消transferState（）中对nowState中reqContent属性的设置，
		 //nowState.setReqContent(reqContent);
	（4）取消transferState（）中的状态转移操作
	（5）修改transferState（）的返回值为String
	（6）取消StateServiceOnUserLogin（）方法中“并用该状态初始化stateTransfer”的操作，改在StateService声明stateTransfer就进行初始化
	（7）初始化转移矩阵时
		1）取消transferMapSTUserPwd等
		2）将transferMapSTUserHelp改名为transferMapSTUser
		3）所有STUser状态下的转移都put到transferMapSTUser中，最后把transferMapSTUser加入stateMap
			//2018-11-18
			//初始化SceneType.STUser场景的转移出口，包括help、pwd********************
			HashMap<String, Func<StateStack,String,String> > transferMapSTUser = new HashMap<String, Func<StateStack,String,String>>();   
			//新增SceneType.STUser场景的转移出口help
			transferMapSTUser.put("help", FuncBase::help);
			//新增SceneType.STUser场景的转移出口help
			transferMapSTUser.put("pwd", FuncBase::pwd);
			//所有STUser状态下的转移都put到transferMapSTUser中，最后把transferMapSTUser加入stateMap
			stateMap.put(SceneType.STUser, transferMapSTUser);
6.修改CoreServiceImplJHSBC.java
	（1）新增成员stateService
	（2）取消成员stateTransfer和stateStack
	（3）取消直接处理
	/*   		//从数据库查询用户信息
	        	User user = null;
	        	user = db.getUserInfo(fromUserName);
	        	int idUser = 0;
	        	//如果没有查到就插入一条用户记录
	        	if (null == user) {
	        		User newUser = new User();
	        		newUser.setWeixinId_User(fromUserName);
	        		//int idUser = db.insertNewUser(newUser);
	        		db.insertNewUser(newUser);        		
	        		idUser  = newUser.getId_User();
	        		
	        	}else{//如果查询到就记录到状态栈中
	        		idUser = user.getId_User();    			
	        	}//if (null == user) 
	
	        	//如果查询idUser错误，或新增用户失败则返回
	        	if(0 == idUser)
	        		return "新增用户失败";
	        	     	
	    		//获取用户idUser成功后，如果是首次登录（状态栈为空），就记录到状态栈中，并用该状态初始化stateTransfer
	    		if (stateStack.sizeof() == 0) {
	    			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
	    			stateStack.push(state);
	    			
	    			stateTransfer = new StateTransfer(state);
	    			
	    		}
	        	        	
	        	//在返回语开头加上下文信息
	        	respContent = stateStack.getContext();*/
	    改为引用stateService类的方法StateServiceOnUserLogin（）
    		respContent = stateService.StateServiceOnUserLogin(fromUserName);
	（3）移除StateProccedue定义   
	（4）注释掉所有switch (reqContent)的内容 ,在对应未知加入
			// 如果是其它文本则进一步处理
			//进入状态机处理
			respContent = stateService.StateProccedue(reqContent);
    		System.out.println(respContent);
    		textMessage.setContent(respContent);
    		respMessage = textMessageUtil.messageToxml(textMessage);
    		return respMessage;
7.修改StateStack.java
	（1）将方法getCurrentState() 中的
			return stack[top];
		改为
			return stack[top-1]; 
			
#commit#
2018-11-18/3
1.修改CoreServiceImplJHSBC.java
	（1）由于不直接操作数据库，注释掉成员DbService db
			//数据库操作对象
			//private DbService db = new DbService();
2.修改FuncBase.java
	（1）新增DbService db
			//数据库操作对象
			private DbService db = new DbService();
	（2）修改现有的两个转移处理函数help和pwd，取消对state.respContent的写入
	（3）修改pwd，不使用stateStack.getContext();而使用stateStack.getPwd();
	（4）完善whoami
	（5）在转移表中增加TSUER场景的whoami操作
			//新增SceneType.STUser场景的转移出口whoami
			transferMapSTUser.put("whoami", FuncBase::whoami);	
	（6）将所有函数的2个字符串参数合并为1个
			String str1, String str2
			-》
			String str
	
3.修改State.java
	（1）取消两个成员
			//增加两项，分别是最近的用户输入，和最近给用户的输出
			//private String reqContent;
			//private String respContent;
4.修改StateStack.java
	（1）增加一个返回当前场景的函数
				public String getPwd()
5.修改StateService.java
	（1）修改StateProccedue()
			原来按空格分为多个子串，取前前三个作为transferState的输入，
		/*		String[] strArray = reqContent.split(" ");
				String strOrder = strArray[0];
				String strArg1 = (strArray.length>1?strArray[1]:null);
				String strArg2 = (strArray.length>2?strArray[2]:null);*/
			改为在第一个空格处将整个串分成两部分，第一部分作为命令，后一部分整体作为参数	
				String strOrder;
				String strArgs;
				int index = reqContent.indexOf(' ');
				if (index>0) {
					strOrder = reqContent.substring(0,reqContent.indexOf(' ')); 
					strArgs = reqContent.substring(reqContent.indexOf(' ')+1); // "tocirah sneab"
				}else {
					//用户只输入了单个词
					strOrder = reqContent;
				}
	（2）修改
			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
		为
			State state = new State(idUser,Const.tablename_User,0,"用户:"+fromUserName,SceneType.STUser);
6.修改StateTransfer.java
	（1）修改transferState（）的参数
		取消
			String reqContent
		将
			String strArg1, String strArg2
		合并为
			String strArgs
	（2）将
		Func<StateStack,String,String>
		改为
		Func<StateStack,String>
7.修改Func.java
	将
		public interface Func<S, T1, T2>
	改为
		public interface Func<S, T>	
8.新建一个scene_state包，把和状态、场景相关的类都放到这个包中
9.新写一个工具类DbCommonUtil.java。可以连接数据库，进行通用的增删改查操作，作为mybatis的互补。
10.修改Const.java
	（1）新增DbCommonUtil用来初始化数据库连接的
		//jdbc
		public static final String jdbcUrl = "jdbc:mysql://127.0.0.1:3306/java?useUnicode=true&characterEncoding=utf-8";
		//数据库用户名
		public static final String dbUser = "root";
		//数据库用户密码
		public static final String dbPwd = "pyt999";

		
2018-11-19
1.修改Const.java
	（1）新增各表名对应的id号
			public static final HashMap<String,String> mapTableId= new HashMap<String,String>(){{
				put(tablename_User,"Id_User");
					put(tablebame_Project,"Id_Project");
						put(tablebame_Function,"Id_Function");
							put(tablebame_FuncStatement,"Id_FuncStatement");
							put(tablebame_FuncVar,"Id_FuncVar");
								put(tablebame_FuncVarItem,"Id_FuncVarItem");
						put(tablebame_Var,"Id_Var");
							put(tablebame_VarItem,"Id_VarItem");
				put(tablebame_Struct,"Id_Struct");
					put(tablebame_StructItem,"Id_StructItem");
				put(tablebame_Type,"Id_Type");
			}
			};
	（2）新增数据库名
			public static final String dbSchema = "java";
			
2.修改FuncBase.java
	（1）修改whoami，输出每个字段的值
	（2）修改lsp
3.修改ProjectMapper.xml
	（1）增加
			<!-- 2018-11-19 自己加的 -->
			<select id="selectProjectsByUserId"
				parameterType="java.lang.String" resultMap="BaseResultMap">
				SELECT Project.*
				FROM User,Role,UserRoleRelation,Permission,RolePRMSRelation,Project
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
				AND User.Id_User =
				UserRoleRelation.Id_User
				AND UserRoleRelation.Id_Role = Role.Id_Role
				AND Role.Id_Role = RolePRMSRelation.Id_Role
				AND RolePRMSRelation.Id_Permission = Permission.Id_Permission
				AND Permission.Id_Project = Project.Id_Project
			</select>
4.修改ProjectMapper.java
	（1）增加
		 List<Project> selectProjectsByUserId(@Param("IdUser") int intUserId);
5.修改DbService.java
	（1）增加
		    public List<Project> getProjectsInfoByUserId(int intUserId) {
	        //public Project getProjectsInfo(String strWeixinId) {
	        	SqlSession session = sessionFactory.openSession();
	        	List<Project> projects = null;
	        	//Project projects = null;
	        	ProjectMapper mapper = session.getMapper(ProjectMapper.class);
	        	try {
	        		projects = mapper.selectProjectsByUserId(intUserId);
	        		session.commit();
	        	} catch (Exception e) {
	        		e.printStackTrace();
	        		session.rollback();
	        	}                 
	        	return projects;
	        }


2018-11-20
0.修改FuncBase.java
	（1）完善lss
	（2）完善lst
	（3）完善cdp
1.修改TypeMapper.xml
	（1）增加
		<select id="selectTypesByUserId"
			parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT Type.* FROM User,TypeUserRelation,Type
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
					AND User.Id_User = TypeUserRelation.Id_User
					AND TypeUserRelation.Id_Type = Type.Id_Type
	 	</select>
2.修改StructMapper.xml
	（1）增加
		  <!-- 2018-11-20 自己加的 -->
		  <select id="selectStructsByUserId"
				parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Struct.* FROM User,StructUserRelation,Struct
					WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
						AND User.Id_User = StructUserRelation.Id_User
						AND StructUserRelation.Id_Struct = Struct.Id_Type
		  </select>
3.修改TypeMapper.java
	（1）增加
		 List<Type> selectTypesByUserId(@Param("IdUser") int intUserId);
4.修改StructMapper.java
	（1）增加
		 List<Struct> selectStructsByUserId(@Param("IdUser") int intUserId);
5.修改DbService.java
	（1）增加
		    public List<Type> getTypesInfoByUserId(int intUserId) {
	        
	        	SqlSession session = sessionFactory.openSession();
	        	List<Type> types = null;
	        	
	        	TypeMapper mapper = session.getMapper(TypeMapper.class);
	        	try {
	        		types = mapper.selectTypesByUserId(intUserId);
	        		session.commit();
	        	} catch (Exception e) {
	        		e.printStackTrace();
	        		session.rollback();
	        	}                 
	        	return types;
	    	}
    （2）增加
		    public List<Struct> getStructsInfoByUserId(int intUserId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	List<Struct> structs = null;
		    	
		    	StructMapper mapper = session.getMapper(StructMapper.class);
		    	try {
		    		structs = mapper.selectStructsByUserId(intUserId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return structs;
		    }
		        
    （3）增加
		    public Project getProjectByProjectId(int intProjectId) {
		      
		        	SqlSession session = sessionFactory.openSession();
		        	Project project = null;
		        	
		        	ProjectMapper mapper = session.getMapper(ProjectMapper.class);
		        	try {
		        		project = mapper.selectByPrimaryKey(intProjectId);
		        		session.commit();
		        	} catch (Exception e) {
		        		e.printStackTrace();
		        		session.rollback();
		        	}                 
		        	return project;
		    }
#未完成#6.写一个测试Core

2018-12-02（修改了数据库，经过mybatis自动对象的再次生成：run as-》mybatis generate）
0.修改数据库，在Type表上增加名字和注释两个字段
	ALTER TABLE `java`.`Type` 
		ADD COLUMN `Name_Type` VARCHAR(45) NULL AFTER `Id_NameSpace_Type`,
		ADD COLUMN `Memo_Type` VARCHAR(45) NULL AFTER `Name_Type`;
1.修改数据库后，重新执行工程右键-》run as mybatis generator。
	之后发现大部分之前的修改都在，包括添加的sql，但是调试发现新建工程的时候取不到新插入的project的id。发现问题在于之前的一处修改在重新调用mybastis generator的时候被改了回去
	重新进行修改
	（1）ProjectMapper.xml
	  	<insert id="insertSelective" parameterType="org.iscas.tj2.pyt.springboot_mybatis.domain.Project">
	  改为
		<insert id="insertSelective" parameterType="org.iscas.tj2.pyt.springboot_mybatis.domain.Project" useGeneratedKeys="true" keyProperty="idProject">
	（2）相应地修改所有.xml
2.修改FuncBase.java
	（1）完善addp
	（2）完善adds	
	（3）完善addt

3.修改StructMapper.xml
	（1）将
		AND StructUserRelation.Id_Struct = Struct.Id_Type
		改为
		AND StructUserRelation.Id_Struct = Struct.Id_Struct

4.修改DbService.java
	（1）增加getTypeByTypeId
		    public Type getTypeByTypeId(int intTypeId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	Type type = null;
		    	
		    	TypeMapper mapper = session.getMapper(TypeMapper.class);
		    	try {
		    		type = mapper.selectByPrimaryKey(intTypeId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return type;
		    }
    （2）增加getStructByStructId
		    public Struct getStructByStructId(int intStructId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	Struct struct = null;
		    	
		    	StructMapper mapper = session.getMapper(StructMapper.class);
		    	try {
		    		struct = mapper.selectByPrimaryKey(intStructId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return struct;
		    }

		        
    （3）增加
		    public int createStruct(int idUser,Struct struct) {
		    	SqlSession session = sessionFactory.openSession();
		    	int idStruct = 0;
		    	int idStructUserRelation = 0;
		
		    	StructMapper structMapper = session.getMapper(StructMapper.class);
		    	StructUserRelationMapper structUserRelationMapper = session.getMapper(StructUserRelationMapper.class);
		    	try {
		    		//插入Struct表
		    		structMapper.insertSelective(struct);
		    		idStruct = struct.getIdStruct();
		    		if (0 == idStruct) {
		    			return -1;
		    		}   		    		
		    		
		    		//插入StructUserRelation
		      		StructUserRelation structUserRelation = new StructUserRelation();
		    		structUserRelation.setIdStruct(idStruct);
		    		structUserRelation.setIdUser(idUser);
		    		structUserRelationMapper.insertSelective(structUserRelation);
		    		idStructUserRelation = structUserRelation.getIdStructuserrelation();
		    		if (0 == idStructUserRelation) {
		    			session.rollback();
		    			return -2;
		    		} 
		    		session.commit();
		    		
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return 0;
		    }   
		    
2018-12-03
1.修改FuncBase.java
	（1）完善cdp
	（2）完善cds	
	（3）完善cdt
	以上函数，均做如下修改
	（1）将
			db.getProjectByProjectId(state.getIntId())
		改为
			db.getStructByStructId(Integer.parseInt(str))
	（2）查询相应的dao对象后，先做是否为空的判断
		if (project/struct/type == null ) {
			return "cd失败，查询不到您指定的对象";			
		}
2.初始化SceneType.STProject场景的转移出口

#commit #
2018-12-03/2
0.修改数据库
	（1）将所有外键引用改为cascade
		原因：无法删除用户的struct、type、project
	（2）在StructItem中设置指向Struct的外键
	（3）在（2）之后 2018-12-03 18:50重新调用了mybatis generator
	（4）在所有.xml的insertSelective中增加useGeneratedKeys="true" keyProperty="XXX">

1.修改FuncBase.java
	（1）完善delp
	（2）完善dels	
	（3）完善delt
	（4）完善lssi
	（5）完善cdsi
	（6）完善delsi
	（7）完善lsf
	（8）完善addf
	（9）完善lsv
	（10）完善addv
	（11）完善delv
	（12）完善cdv
	（13）完善delf
	（14）完善cdf
2.修改DbService.java
	（1）增加deleteProjectByProjectId
	（2）增加deleteTypeByTypeId
	（3）增加deleteStructByStructId
	（4）增加getStructItemsInfoByStructId
	（5）增加getStructItemByStructItemId
	（6）增加createStructItem
	（7）增加deleteStructItemByStructItemId
	（8）增加getFunctionsInfoByProjectId
	（9）增加createFunction
	（10）增加deleteFunctionByFunctionId
	（11）增加getVarByVarId
	（12）增加deleteVarByVarId
	（13）增加createVar
3.修改StateTransfer.java
	（1）根据Const.java中关于STXXX_HELP的定义，补全状态转移表中的
		transferMapSTStruct
		transferMapSTStructItem
		transferMapSTType
		transferMapSTProject	
		transferMapSTFunc	
		transferMapSTFuncStatement
		transferMapSTFuncVar
		transferMapSTFuncVarItem
		transferMapSTVar
		transferMapSTVarItem
4.修改StructItemMapper.xml
	（1）增加
			<!-- 2018-12-03 自己加的 -->
			<select id="selectStructItemsByStructId"
				parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT StructItem.* FROM StructItem,Struct
				WHERE Struct.Id_Struct = #{IdStruct,jdbcType=INTEGER}
				AND Struct.Id_Struct = StructItem.Id_Struct
			</select>
5.修改StructItemMapper.java
	（1）增加
		List<StructItem> selectStructItemsByStructId(@Param("IdStruct") int intStructId);	
6.修改FunctionMapper.java
	（1）增加
		<select id="selectFunctionsByProjectId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT Function.* FROM Function,Project,FuncProjectRelation
			WHERE Project.Id_Project = #{IdProject,jdbcType=INTEGER}
			AND Project.Id_Project = FuncProjectRelation.Id_Project
			AND Function.Id_Function = FuncProjectRelation.Id_Function
		</select>
7.修改FunctionMapper.java
	（1）增加
		List<Function> selectFunctionsByProjectId(@Param("IdProject") int intProjectId);	

8.修改VarMapper.java
	（1）增加		
	 	<select id="selectVarsByProjectId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT Var.* FROM Var,Project,VarProjectRelation
			WHERE Project.Id_Project = #{IdProject,jdbcType=INTEGER}
			AND Project.Id_Project = VarProjectRelation.Id_Project
			AND Var.Id_Var = VarProjectRelation.Id_Var
		</select>		
9.修改VarMapper.java
	（1）增加
		List<Var> selectVarsByProjectId(@Param("IdProject") int intProjectId);	
10.为了避免用户在类似“cdv 2”的指令中给出不能转化为整形的参数，修改所有直接引用Integer.parseInt(str)的地方

#commit#
1.修改FuncBase.java
	（1）完善lsvi
	（2）完善addvi	
	（3）完善delvi
	（4）完善cdvi
	（1）完善lsfvi
	（2）完善addfvi	
	（3）完善delfvi
	（4）完善cdfvi	
	（5）完善lsfv
	（6）完善addfv	
	（7）完善delfv
	（8）完善cdfv
2.修改DbService.java
	（1）增加getVarItemsInfoByVarId
	（2）增加getVarItemByVarItemId
	（3）增加createVarItem
	（4）增加deleteVarItemByVarItemId
	（5）增加getFuncVarItemsInfoByFuncVarId
	（6）增加getFuncVarItemByFuncVarItemId
	（7）增加createFuncVarItem
	（8）增加deleteFuncVarItemByFuncVarItemId
	（9）增加getFuncVarsInfoByVarId
	（10）增加getFuncVarByFuncVarId
	（11）增加createFuncVar
	（12）增加deleteFuncVarByFuncVarId
4.修改VarItemMapper.xml
	（1）增加
		<select id="selectVarItemsByVarId"
			parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT VarItem.* FROM VarItem,Var
			WHERE Var.Id_Var = #{IdVar,jdbcType=INTEGER}
			AND Var.Id_Var = VarItem.Id_Var
		</select>
5.修改VarItemMapper.java
	（1）增加
		List<VarItem> selectVarItemsByVarId(@Param("IdVar") int intVarId);	
6.修改StateTransfer.java
	修改状态转移表初始化中，整段复制命令后，没有做相应修改的问题
7.修改FuncVarItemMapper.xml
	（1）增加
		<select id="selectFuncVarItemsByFuncVarId"
			parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT FuncVarItem.* FROM FuncVarItem,FuncVar
			WHERE FuncVar.Id_FuncVar = #{IdFuncVar,jdbcType=INTEGER}
			AND FuncVar.Id_FuncVar = FuncVarItem.Id_FuncVar
		</select>
8.修改FuncVarItemMapper.java
	（1）增加	
		List<FuncVarItem> selectFuncVarItemsByFuncVarId(@Param("IdFuncVar") int intFuncVarId);
		
9.修改FuncVarMapper.java
	（1）增加		
		  <select id="selectFuncVarsByFunctionId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
					SELECT FuncVar.* FROM FuncVar,Function
					WHERE Function.Id_Function = #{IdFunction,jdbcType=INTEGER}
					AND Function.Id_Function = FuncVar.Id_Function
		  </select>
10.修改FuncVarMapper.java
	（1）增加
		List<FuncVar> selectFuncVarsByFunctionId(@Param("IdFunction") int intFunctionId);

11.修改FuncStatementMapper.java
	（1）增加		
		<select id="selectFuncStatementsByFunctionId"
			parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT FuncStatement.* FROM FuncStatement,Function
			WHERE Function.Id_Function = #{IdFunction,jdbcType=INTEGER}
			AND Function.Id_Function = FuncStatement.Id_Function
		</select>		
12.修改FuncStatementMapper.java
	（1）增加
		List<FuncStatement> selectFuncStatementsByFunctionId(@Param("IdFunction") int intFunctionId);
		
13.	为按场景的枚举类型返回中文，定义如下数组
	private String[] STCNAME = {
			"用户","结构","结构字段","类型","工程","函数","函数语句","函数变量","函数变量字段","全局变量","全局变量字段"
	};		
14.在所有add操作，用到参数的地方检查参数是否为空

#commit#（含数据库）

2018-12-04/2
1.成功部署到深信服服务器
2.测试发现深信服上的数据库有问题，排查发现是外键约束引用的表名user、role为小写。因mac对大小写不敏感所以把这两个表改为大写后没有暴露此问题。
3.用mysqlworkbench修改深信服服务器数据库（mac本地库无法修改，改了大写仍为小写），此问题解决。
4.用深信服数据库倒入导入到本地，加入工程，并替换mac本地库。


2018-12-05
1.无法识别时，直接输出help信息
2.将用户输入变为小写	
	strOrder = strOrder.toLowerCase();


2018-12-7
一、测试时发现，用户2登录后，身份是用户1.分析是调用StateService的OnUserLogin函数后，虽然在User表里插入了相应记录，但是共用了同一个StateService，导致判断“stateTransfer.stateStack.sizeof() == 0”得不到预期结果（判用户是是否首次登录）。
1.修改Const.java
	新增
		public static final int maxUserNumber = 1000;
2.修改StateServer.java（此文件一直没有纳入git，导致删除StateServiceOnUserLogin（）函数后，需要手动恢复）
	（1）重建StateServiceOnUserLogin（）函数
	（2）修改
			public String StateProccedue(String reqContent) {
		为
			public String StateProccedue(int idUser,String reqContent) {
		将
			String strReturn = stateTransfer.transferState(strOrder, strArgs);
		改为
			String strReturn = stateTransfer.transferState(idUser,strOrder, strArgs);
3.修改StateTransfer.java
	（1）增加
		public StateStack[] stateStacks;
	（2）在构造函数中增加
			for(int i=0;i<Const.maxUserNumber;i++) {
				stateStacks[i] = null;
			}	
	（3）修改
		public String transferState(String strOrder, String strArgs) {
		为
		
		函数中的stateStack改为stateStacks[idUser]
	（4）注释掉
		public StateStack stateStack = new StateStack(Const.maxStackDepth);
4.修改CoreServiceImpJHSBC
	（1）将
			respContent = stateService.StateServiceOnUserLogin(fromUserName);
		改为
			
	（1）将
			respContent = stateService.StateProccedue(reqContent);
		改为
			respContent = stateService.StateProccedue(idUser,reqContent);
二、增加授权功能
0.修改数据库，将Permission表所有的Right_Permission字段都由1改为0（配合枚举类型中CREATETOR的序号）
1.新建枚举类型
	public enum PermisionType {
		CREATE,
		GRANTED	
	}
2.修改FuncBase.java
	（1）将
			int rightPermission = 1;
		改为
    		int rightPermission = PermisionType.CREATE.ordinal();	
    （2）新增一个函数
    	public static String grant(StateStack stateStack, String str)
 3.修改DbService.java
 	（1）新增
 		public int grantProjectToUser(int idUser,int idProject) {
 	（2）新增
 		public List<Project> getSelfCreatedProjectsInfoByUserId(int intUserId) {
 	（3）新增
 		public List<Permission> getPermissionsByGivenProjectAndRight(int IdProject,int IdRight)
 4.修改PerjectMapper.java
 	（1）新增
 		List<Project> selectSelfCreatedProjectsByUserId(@Param("IdUser") int intUserId);
 5.修改PerjectMapper.xml
 	（1）将
		 	  <select id="selectProjectsByUserId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Project.*
				FROM User,Role,UserRoleRelation,Permission,RolePRMSRelation,Project
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
				AND User.Id_User = UserRoleRelation.Id_User
				AND UserRoleRelation.Id_Role = Role.Id_Role
				AND Role.Id_Role = RolePRMSRelation.Id_Role
				AND RolePRMSRelation.Id_Permission = Permission.Id_Permission
				AND Permission.Id_Project = Project.Id_Project
		 	 </select>
  		改为
		    <select id="selectProjectsByUserId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Project.*
				FROM User,Role,UserRoleRelation,Permission,RolePRMSRelation,Project
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
				AND User.Id_User = UserRoleRelation.Id_User
				AND UserRoleRelation.Id_Role = Role.Id_Role
				AND Role.Id_Role = RolePRMSRelation.Id_Role
				AND RolePRMSRelation.Id_Permission = Permission.Id_Permission
				AND Permission.Id_Project = Project.Id_Project
				AND Permission.Right_Permission in (0,1)
		 	 </select>
	（2）新建selectSelfCreatedProjectsByUserId，只选取自己创建的工程
			<select id="selectSelfCreatedProjectsByUserId" parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Project.*
				FROM User,Role,UserRoleRelation,Permission,RolePRMSRelation,Project
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
				AND User.Id_User = UserRoleRelation.Id_User
				AND UserRoleRelation.Id_Role = Role.Id_Role
				AND Role.Id_Role = RolePRMSRelation.Id_Role
				AND RolePRMSRelation.Id_Permission = Permission.Id_Permission
				AND Permission.Id_Project = Project.Id_Project
				AND Permission.Right_Permission = 0
		 	 </select>

6.修改PermissionMapper.xml
	（1）新增
		  <!-- 2018-12-07 新增选取Id_Project和Right_Perssion符合要求的 -->
		  <select id="selectByGivenProjectAndRight" parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Permission.*
				FROM Permission
				WHERE Permission.Id_Project = #{IdProject,jdbcType=INTEGER}
				AND Permission.Right_Permission = #{IdRight,jdbcType=INTEGER}
		  </select>
7.修改PermissionMapper.java
	（1）新增
			List<Permission> selectByGivenProjectAndRight(@Param("IdProject") int IdProject, @Param("IdRight") int IdRight);
8.			
对不存在的用户的grant说不，grant时如果有相应的role和permission不再新增

2018-12-10
0.修改数据库
	（1）User表的第1个用户，weixinid改为admin。用于公共用户。作为根用户。
1.修改FuncBase.java
	（1）修改lsfs函数，不再输出函数行号，而是输出内容
			strReturn += "函数语句id:" + funcStatement.getIdFuncstatement() + "; 函数语句行号:"+funcStatement.getLinenoFuncstatement(); 
	（2）给STUser场景增加一个处理函数common，“退回”到公共用户
			public static String common(StateStack stateStack, String str) {
				
				System.out.println("common: arg=" + str);
				
				String strReturn = null;
				if(stateStack.sizeof()>1) {
					stateStack.pop();
					State state = stateStack.getCurrentState();
					strReturn = "进入共用空间 "+ state.getSceneType().toString() + ": ";
					strReturn += Const.mapHelpInfo.get(state.getSceneType());
				}else {
					strReturn = "无法操作，你已经在根路径";
				}
				return strReturn;
			}// 进入到公共空间
	（3）以STUser场景函数为模版，增加一组STCommon场景的函数，在STUser场景函数的基础上，去掉whoami、pwd和attr，
		其它的函数名前加c，函数中取用户Id的地方将
			state.getIntId()
		替换为
			Const.UserIdOfAdmin
2.修改SceneType.java
	（1）增加一个场景
			STCommon
3.修改Const.java
	（1）增加一组帮助信息
			public static final String STCommon_HELP = "您可用的命令：\n"
					+ "help   -列出此帮助信息\n"
					+ "lsp   -列出所有project\n"
					+ "lst   -列出所有type\n"
					+ "lss   -列出所有struct\n"
					+ "cdp id   -进入指定的project\n"
					+ "cdt id   -进入指定的type\n"
					+ "cds id   -进入指定的struct\n"
					+ "addp name   -新增一个project\n"
					+ "addt name   -新增一个type\n"
					+ "adds name   -新增一个struct\n"
					+ "delp id   -删除一个project\n"
					+ "delt id   -删除一个type\n"
					+ "dels id   -删除一个struct\n"
					+ "my   -回到用户场景";

	（2）修改STUser_HELP，增加
			+ "common   -查看共用对象";
	（3）增加常量
			public static final int maxUserNumber = 1000;
	（4）修改
			public static final Map<SceneType, String> mapHelpInfo = new HashMap<SceneType, String>(){{
				put(SceneType.STUser, STUser_HELP);
				put(SceneType.STStruct, STStruct_HELP);
				put(SceneType.STStructItem, STStructItem_HELP);
				put(SceneType.STType, STType_HELP);
				put(SceneType.STProject, STProject_HELP);
				put(SceneType.STFunc, STFunc_HELP);
				put(SceneType.STFuncStatement, STFuncStatement_HELP);
				put(SceneType.STFuncVar, STFuncVar_HELP);
				put(SceneType.STFuncVarItem, STFuncVarItem_HELP);
				put(SceneType.STVar, STVar_HELP);
				put(SceneType.STVarItem, STVarItem_HELP);
			}};
		为
			public static final Map<SceneType, String> mapHelpInfo = new HashMap<SceneType, String>(){{
				put(SceneType.STCommon, STCommon_HELP);	
				put(SceneType.STUser, STUser_HELP);
				put(SceneType.STStruct, STStruct_HELP);
				put(SceneType.STStructItem, STStructItem_HELP);
				put(SceneType.STType, STType_HELP);
				put(SceneType.STProject, STProject_HELP);
				put(SceneType.STFunc, STFunc_HELP);
				put(SceneType.STFuncStatement, STFuncStatement_HELP);
				put(SceneType.STFuncVar, STFuncVar_HELP);
				put(SceneType.STFuncVarItem, STFuncVarItem_HELP);
				put(SceneType.STVar, STVar_HELP);
				put(SceneType.STVarItem, STVarItem_HELP);
			}};

4.修改StateTransfer.java
	（1）在状态转移表的USER场景下，增加1个出口
		// 新增SceneType.STUser场景的转移出口common
		transferMapSTUser.put("common", FuncBase::common);
	（2）在状态转移表中增加COMMON场景
5.修改StateService.java
	（1）将
			stateTransfer.stateStacks[idUser] = new StateStack(Const.maxStackDepth);
		改为
			stateTransfer.stateStacks[idUser] = new StateStack(Const.maxStackDepth);
			State state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommon);
			stateTransfer.stateStacks[idUser].push(state);
	（2）将
			State state = new State(idUser,Const.tablename_User,0,"用户："+fromUserName,SceneType.STUser);
		改为
			State state = new State(idUser,Const.tablename_User,1,"用户："+fromUserName,SceneType.STUser);

	（3）将用户登录，将STUSER场景压入状态栈的操作注释掉
			if(stateTransfer.stateStacks[idUser].sizeof() == 0 )
		改为（注意判断条件由==0改为==1）
			//如果用户对应的状态栈为空就把当前状态压入栈		
			if(stateTransfer.stateStacks[idUser].sizeof() == 1 ) {
				State state = new State(idUser,Const.tablename_User,1,"用户："+fromUserName,SceneType.STUser);
				stateTransfer.stateStacks[idUser].push(state);			
			}
	（4）为了在用户退回公共空间后不回因为以下语句再次直接回到用户空间注销（3）中的语句
6.修改StateStack.java
	（1）将
			private String[] STCNAME = {
					"用户","结构","结构字段","类型","工程","函数","函数语句","函数变量","函数变量字段","全局变量","全局变量字段"
			};
		改为
			private String[] STCNAME = {
					"用户","结构","结构字段","类型","工程","函数","函数语句","函数变量","函数变量字段","全局变量","全局变量字段","共用对象"
			};		
	
	
2018-12-11
1.修改StateService.java
	（1）将
			strOrder = strOrder.toLowerCase();
			String strReturn = stateTransfer.transferState(idUser,strOrder, strArgs);
		改为
			strOrder = strOrder.toLowerCase();
			//2018-12-11 如果是my指令，则直接操作
			if(stateTransfer.stateStacks[idUser].sizeof() == 1 && strOrder.equals("home")) {
				State state = new State(idUser,Const.tablename_User,1,"用户："+idUser,SceneType.STUser);
				stateTransfer.stateStacks[idUser].push(state);	
				return "进入用户空间";
			}
	（2）将
			State state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommon);
			stateTransfer.stateStacks[idUser].push(state);
		改为
			//2018-12-10 增加下面两行
			State state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommon);
			//2018-12-11 增加下面判断，如果是管理员用户，在state中做记录
			if(fromUserName.equals(Const.AdminUserWeixinId) ) {
				state.setIsAdmin(true);
			}
			stateTransfer.stateStacks[idUser].push(state);
	（3）取消修改（2），当用户是admin时，第一个状态节点的场景定为STCommonAdmin
		将
			//2018-12-10 增加下面两行
			State state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommon);
			//2018-12-11 增加下面判断，如果是管理员用户，在state中做记录
			if(fromUserName.equals(Const.AdminUserWeixinId) ) {
				state.setIsAdmin(true);
			}
		改为
			stateTransfer.stateStacks[idUser].push(state);
			State state;
			if(fromUserName.equals(Const.AdminUserWeixinId)) {
				state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommonAdmin);
			}else{
				state = new State(Const.UserIdOfAdmin,Const.tablename_User,0,"根用户",SceneType.STCommonUser);
			}
			stateTransfer.stateStacks[idUser].push(state);
2.修改StateTransfer.java
	（1）取消SceneType.STCommon场景的转移出口my
	（2）增加SceneType.STCommon场景的转移出口pwd
	（3）将“STCommon”替换为“STCommonAdmin”
	（4）增加STCommonUser场景的状态转移项
			//初始化SceneType.STCommonUser场景的转移出口，包括help、pwd、whoami、attr********************
			HashMap<String, Func<StateStack,String> > transferMapSTCommonUser = new HashMap<String, Func<StateStack,String>>();   
			//新增SceneType.STCommonUser场景的转移出口help
			transferMapSTCommonUser.put("help", FuncBase::help);
			//新增SceneType.STCommonUser场景的转移出口help
			transferMapSTCommonUser.put("pwd", FuncBase::pwd);
			//新增SceneType.STCommonUser场景的转移出口lsf
			transferMapSTCommonUser.put("lsf", FuncBase::clsf);
			//新增SceneType.STCommonUser场景的转移出口lst
			transferMapSTCommonUser.put("lst", FuncBase::clst);
			// 新增SceneType.STCommonUser场景的转移出口lss
			transferMapSTCommonUser.put("lss", FuncBase::clss);
			// 新增SceneType.STCommonUser场景的转移出口cdp
			transferMapSTCommonUser.put("cdp", FuncBase::ccdp);
			// 新增SceneType.STCommonUser场景的转移出口cdt
			transferMapSTCommonUser.put("cdt", FuncBase::ccdt);
			// 新增SceneType.STCommonUser场景的转移出口cds
			transferMapSTCommonUser.put("cds", FuncBase::ccds);		
3.修改FuncBase.java
	（1）修改dc函数
		dc后不输出help信息（太乱）
		//strReturn += Const.mapHelpInfo.get(state.getSceneType());
	（2）增加clsf函数
	（3）增加ccdf函数
4.修改Const.java
	（1）增加AdminUserWeixinId，记录管理员用户的微信id
			public static final String AdminUserWeixinId = "ocaDy1CWp497l5Kq21mkw3HflzaY";
	（2）将“Common”替换为“CommonAdmin”
	（3）增加场景STCommonUser的help信息
		public static final String STCommonUser_HELP = "您可用的命令：\n"
			+ "help   -列出此帮助信息\n"
			+ "pwd   -显示当前所处的场景\n"
			+ "lsf   -列出所有函数\n"
			+ "lst   -列出所有type\n"
			+ "lss   -列出所有struct\n"
			+ "cdf id   -进入指定的函数\n"
			+ "cdt id   -进入指定的type\n"
			+ "cds id   -进入指定的struct\n"
			+ "home   -回到用户场景";
	（4）在mapHelpInfo初始化中增加
		 put(SceneType.STCommonUser, STCommonUser_HELP);
	
5.修改State.java	
	（1）增加成员变量
			private boolean isAdmin;
		表示是否管理员，决定对公共对象的访问权限，如果是我的微信登录则是管理员，否则是别人登录，目的是显示不同的help信息，支持不同的命令
6.修改SceneType.java
	（1）将
			STCommon,
		改为
			STCommonUser,
	（2）新增
			STCommonAdmin
7.修改StateStack.java
	（1）将
			private String[] STCNAME = {
					"用户","结构","结构字段","类型","工程","函数","函数语句","函数变量","函数变量字段","全局变量","全局变量字段","共用对象"
			};
		改为
			private String[] STCNAME = {
					"用户","结构","结构字段","类型","工程","函数","函数语句","函数变量","函数变量字段","全局变量","全局变量字段","共用对象","共用对象(管理员模式)"
			};	

2018-12-12
1.修改StateStack.java
	（1）修改getPwd()函数，如果没有第1层栈，或第1层栈不是STUser那么把第0层栈（即共用对象显示出来），否则不显示。
		将
			public String getPwd() {	
				String strTmp = "";
				for(int i = 0;i<top; i++) {
					//strTmp += stack[i].getSceneType().toString();
					strTmp += STCNAME[stack[i].getSceneType().ordinal()]+stack[i].getIntId();
					strTmp += "/";
				}
				strTmp += ":>";
				return strTmp;		
			}
		改为
			public String getPwd() {
				String strTmp = "";
				int begin = 0;
				if(top>1?stack[1].getSceneType().equals(SceneType.STUser):false) {
					begin = 1;
				}
				for(int i = begin;i<top; i++) {
					//strTmp += stack[i].getSceneType().toString();
					strTmp += STCNAME[stack[i].getSceneType().ordinal()]+(i==0?"":stack[i].getIntId());
					strTmp += "/";
				}
				strTmp += ":>";
				return strTmp;		
			}	
###待改进###
1、函数语句的输入交互方式
	addfs时可输入行号，否则默认递增
2、attr进入编辑模式，直接key=value
3、将判断是否有访问权限的代码，归拢为函数
\4、针对公共代码，增加一种权限——


###错误###

1、虽然不能列出别人创建的工程，但可以用id直接cd


