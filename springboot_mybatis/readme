2018-11-03
1.在DbService上
	@Service("DbService")
	改为
	@Repository("DbService")
2.在CoreServiceImpl上
	@Service("CoreService") 
	改为
	@Service("Normal") 
3.在CoreController上
    @Autowired
    下，添加
    @Qualifier("JHSBC")
4.在CoreController上
	private CoreServiceImplJHSBC jhsbcService;
	改回
	private CoreService coreService;
	
	String respMessage = jhsbcService.processRequest(req);
	改回
	String respMessage = coreService.processRequest(req);
5.去掉CoreServiceImpl中的@Autowired
6.去掉CoreServiceImplJHSBC中的@Autowired
7.工程（右键）-》Run as-》Maven install
	成功生成target/springboot_mybatis-0.0.1-SNAPSHOT.jar
8.jar包不易部署，在pom.xml改jar为war
9.针对易地部署根据（https://blog.csdn.net/soldier_123/article/details/78917227）要排除springboot集成的tomcat“spring-boot-starter-tomcat”。有两种方法啊，暂时都未使用。
10.增加一个包testService
11.在包testService中增加一个接口类ITestService。
12.增加一个对接口类ITestService的实现TestService。
13.在控制组件CoreController中增加对接口ITestService的注入。并仿照post增加一个方法postTest，调用testService.processRequest处理
14.为了打包到深信服服务器（tomcat使用80端口），打包时修改配置application.properties当中配置的端口server.port=8080，由8080改为80。（打包完成后需要改回来）

2018-11-04
1.maven clean之后，maven install，再次出现找不到
	o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in
	发现问题在于新建State类的时候，不当使用了@Autowired，去掉后问题消失，再次maven install，又再次出现
先继续写
1.完善State类
	增加两个属性
		private String strComment; //上下文描述
		private int intDepeth; //上下文深度
	增加setter和getter
2.完善StateStack类
	增加一个返回当前上下文提示字符串的方法context()
3.修改CoreServiceImplJHSBC，根据用户微信号查询User表，如果没有结果就插入一条记录。
4.在DbService中加入一个函数insertNewUser，插入一条新的用户记录
5.修改CoreController，之后可以在http://localhost:8080/hello,http://localhost:8080/test中正确得到返回，而且本地微信调试，修改服务器地址url，通过token验证
	（1）@RequestMapping(value = "core"
		-》
		@RequestMapping(value = ""
	（2）@RequestMapping(value = "test",method = RequestMethod.POST)
		-》
		@RequestMapping("/test")
	（3）@RequestMapping("/")
		->
		@RequestMapping("/hello")
6.修改StateStack，将top初始值从-1改为0，并修改相应的边界条件。
7.CoreServiceImplJHSBC的成员textMessageUtil必须使用@Autowired注入
	@Autowired
	private TextMessageUtil textMessageUtil;	
	否则，会报textMessageUtil是空指针
8.CoreServiceImpl的成员textMessageUtil也必须使用@Autowired注入
9.maven install 未报错
10.maven clean之后再maven install 还是报错

2018-11-07
1.修改StateStack
	将方法context改名为getContext。
	新增getCurrentState方法，取当前的状态
	
2018-11-09
1.将测试过的状态转移/函数指针工程testFuncPointer中的有关类Func、FuncBase、StateTransfer加入到工程里来，工程本身尚未使用这些类

2.去掉对图像、音频、连接等处理，统一在前面作为非文本消息回复无法处理
3.将Const类的属性都改为static，使用中不再进行实例化
4.修改
	（1）将变量
			state
		改为
			stepOfNewProj
	（2）将
			String respContent = "小牛处理请求异常，请稍候再试！";
		改为
			String respContent = "";
		挪到try的外面
	（3）在
			catch (……)
		下加入
			respContent = "小牛处理请求异常，请稍候再试！";
	（4）将变量
			map
		改为
			mapProjInfo
	（5）将
			int idUser = db.insertNewUser(newUser);
		改为
			db.insertNewUser(newUser);
			idUser  = newUser.getId_User();
	（6）将插入状态栈首个状态的操作，改到取得用户idUser之后
	（7）将变量
			stack
		改为
			stateStack
	（8）将
			如果获取用户idUser成功，就记录到状态栈中
			if (0 != idUser) {
		改为
			如果获取用户idUser成功，且状态栈为空，就记录到状态栈中
			if (0 != idUser && stateStack.sizeof() == 0) {
	（9）将
			respContent = "无法处理您发送的非文本消息！";
		改为
			respContent += "无法处理您发送的非文本消息！";
2018-11-11
1.定义枚举类型状态类StateType，替换状态转移表中的String类型。
	public enum StateType {
		/**
		 * 根据数据库整理各对象的层次关系
		 * 属于用户的有Struct、Type、Project
		 * 	属于Project的有Func、Var（全局变量）
		 * 		属于Func的有FuncStatement
		 * 		属于Func的有FuncVar（局部变量）
		 * 		   属于FuncVar的有FuncVarItem
		 * 		属于Var的有VarItem
		 * 属于Struct的有StructItem
		 * 		
		 */
		STUser,
			STStruct,
				STStructItem,
			STType,
			STProject,	
				STFunc,
					STFuncStatement,
					STFuncVar,
						STFuncVarItem,
				STVar,
					STVarItem,
	}
2.修改State类，增加一个stateType，说明这个状态属于那类，比如project就是一类。然后状态转移表以状态类组织，用户进入一个project。不管这个project具体是谁，都属于状态类TypeProject，根据这个状态类决定可以转到那个状态
	private StateType stateType;//状态所属类型,并在构造函数中初始化
3.在FuncBase中增加方法：
	（1）list方法
			public static State newItem(State state, String str1, String str2) {
	（2）
 方法
			public static State add(State state, String str1, String str2) {
	（3）del方法
			public static State del(State state, String str1, String str2) {
3.修改StateTranfer
	（1）将
				private HashMap<String, HashMap<String ,Func<State,String,String> > > stateMap = new HashMap<String ,HashMap<String ,Func<State,String,String> > >();
		改为
				private HashMap<StateType, HashMap<String ,Func<State,String,String> > > stateMap = new HashMap<StateType ,HashMap<String ,Func<State,String,String> > >();
	（2）将原有用于测试的初始化状态转移表stateMap的操作全部注释掉
	
	（3）新增有关StateType.TUser状态出发的转移出口，包括cd/list/add/de
			//2018-11-11
			//新增StateType.STUser状态的转移出口cd（可进StateType.STProject，可进StateType.STVar，可进StateType.STFunc，可进StateType.STStruct，可进StateType.STType。根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTUserCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STUser, transferMapSTUserCd);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口list（可列出Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STUser, transferMapSTUserLs);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口add（可新增Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STUser, transferMapSTUserAdd);
			
			//2018-11-11
			//新增StateType.STUser状态的转移出口del（可删除Struct、Project、Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTUserDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTUserDel.put("del", FuncBase::del);
			stateMap.put(StateType.STUser, transferMapSTUserDel);
	（4）新增有关从StateType.TProject状态出发可做的转移
			//2018-11-11
			//新增StateType.STProject状态的转移出口cd（可进StateType.STProject，可进StateType.STVar，可进StateType.STFunc，可进根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTProjectCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STProject, transferMapSTProjectCd);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口list（可列出Project所属的Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STProject, transferMapSTProjectLs);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口add（可新增Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STProject, transferMapSTProjectAdd);
			
			//2018-11-11
			//新增StateType.STProject状态的转移出口del（可删除Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTProjectDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectDel.put("del", FuncBase::del);
			stateMap.put(StateType.STProject, transferMapSTProjectDel);
				
			//2018-11-11
			//新增StateType.STProject状态的转移出口dc（可退至StateType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTProjectDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTProjectDc.put("dc", FuncBase::dc);
			stateMap.put(StateType.STProject, transferMapSTProjectDc);
	（5）初始化StateType.STFunc状态的转移出口,包括cd/dc/list/add/del
			//2018-11-11
			//新增StateType.STFunc状态的转移出口cd（可进StateType.STFunc，可进StateType.STVar，可进StateType.STFunc，可进根据第一个参数arg1决定进哪一类，根据第二个参数arg2决定进相应类的哪一个）
			HashMap<String, Func<State,String,String> > transferMapSTFuncCd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncCd.put("cd", FuncBase::cd);
			stateMap.put(StateType.STFunc, transferMapSTFuncCd);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口list（可列出Project所属的Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncLs = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncLs.put("ls", FuncBase::ls);
			stateMap.put(StateType.STFunc, transferMapSTFuncLs);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口add（可新增Var、Func根据第一个参数arg1决定列出哪一类，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncAdd = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncAdd.put("add", FuncBase::add);
			stateMap.put(StateType.STFunc, transferMapSTFuncAdd);
			
			//2018-11-11
			//新增StateType.STFunc状态的转移出口del（可删除Var、Func根据第一个参数arg1决定列出哪一类，根据第二个参数arg2决定删除相应类的哪一个，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncDel = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncDel.put("del", FuncBase::del);
			stateMap.put(StateType.STFunc, transferMapSTFuncDel);
				
			//2018-11-11
			//新增StateType.STFunc状态的转移出口dc（可退至StateType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTFuncDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncDc.put("dc", FuncBase::dc);
			stateMap.put(StateType.STFunc, transferMapSTFuncDc);
	（7）初始化StateType.STFuncStatement状态的转移出口,包括dc/vi/more
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口vi（可编辑当前行、Func根据第一个参数arg1决定此行的新内容，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementVi = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementVi.put("vi", FuncBase::vi);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementVi);
			
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口more（可显示当前行，状态不变）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementMore = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementMore.put("more", FuncBase::more);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementMore);
			
			//2018-11-11
			//新增SceneType.STFuncStatement状态的转移出口dc（可退至SceneType.STUser）
			HashMap<String, Func<State,String,String> > transferMapSTFuncStatementDc = new HashMap<String, Func<State,String,String>>();   
			transferMapSTFuncStatementDc.put("dc", FuncBase::dc);
			stateMap.put(SceneType.STFuncStatement, transferMapSTFuncStatementDc);		
			
2018-11-12
1.将枚举类型StateType修改为SceneType
2.备份StateTransfer.java，完全清空其中初始化状态转移表的内容。

2018-11-17
1.在枚举类型定义中，增加注释信息
	STUser, //help,pwd,attr,lsp,lst,lss,cdp,cdt,cds,addp,addt,adds,delp,delt,dels
		STStruct,//help,pwd,attr,lssi(ls),cdsi(cd),addsi(add),delsi(del),dc
			STStructItem,//help,pwd,attr,dc
		STType,//help,pwd,attr,dc
		STProject,	//help,pwd,attr,lsf,lsv,cdf,cdv,addf,addv,delf,delv,dc
			STFunc, //help,pwd,attr,lsfs,lsfv,cdfs,cdfv,addfs,addfv,delfs,delfv,dc
				STFuncStatement,//help,pwd,attr,dc
				STFuncVar,//help,pwd,attr,lsfvi(ls),cdfvi(cd),addfvi(add),delfvi(del),dc
					STFuncVarItem,//help,pwd,attr,dc
			STVar,//help,pwd,attr,lsvi(ls),cdvi(cd),addvi(add),delvi(del),dc
				STVarItem,//help,pwd,attr,dc
2.修改Const.java，
	(1)新增各场景下的help信息字符串
	public static final String STUser_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lsp-列出所有project\n"
			+ "lst-列出所有type\n"
			+ "lss-列出所有struct\n"
			+ "cdp id/name-进入指定的project\n"
			+ "cdt id/name-进入指定的type\n"
			+ "cds id/name-进入指定的struct\n"
			+ "addp name-新增一个project\n"
			+ "addt name-新增一个type\n"
			+ "adds name-新增一个struct\n"
			+ "delp id-删除一个project\n"
			+ "delt id-删除一个type\n"
			+ "dels id-删除一个struct";
	public static final String STStruct_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lssi(ls)-列出struct item\n"
			+ "cdsi(cd) id-进入struct item\n"
			+ "addsi(add) type name-新增struct item\n"
			+ "delsi(del) id-删除struct item\n"
			+ "dc-退回到上一层";
		public static final String STStructItem_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "dc-退回到上一层";
	public static final String STType_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "dc-退回到上一层";
	public static final String STProject_HELP = "可用的命令：\n"
			+ "help-列出此帮助信息\n"
			+ "pwd-显示当前所处的场景\n"
			+ "whoami-显示当前操作的对象\n"
			+ "attr key value-修改当前对象的属性\n"
			+ "lsf-列出function\n"
			+ "lsv-列出全局变量var\n"
			+ "cdf id/name-进入function\n"
			+ "cdv id/name-进入var\n"
			+ "addf name-新增function\n"
			+ "addv name-新增var\n"
			+ "delf id-删除function\n"
			+ "delv id-删除var\n"
			+ "dc-退回到上一层";
		public static final String STFunc_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "lsfs-列出函数语句function statement\n"
				+ "lsfv-列出函数局部变量fuction var\n"
				+ "cdfs id-进入指定的函数语句function statement\n"
				+ "cdfv id-进入指定的函数局部变量fuction var\n"
				+ "addfs content\n-增加一条函数语句function statement"
				+ "addfv name-增加一个函数局部变量fuction var\n"
				+ "delfs id-删除一条函数语句function statement\n"
				+ "delfv id-删除一个函数局部变量fuction var\n"
				+ "dc-退回到上一层";
			public static final String STFuncStatement_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "dc-退回到上一层";
			public static final String STFuncVar_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "lsfvi(ls)-列出函数局部变量字段Function Var Item\n"
					+ "cdfvi(cd)-进入函数局部变量字段Function Var Item\n"
					+ "addfvi(add)-新增函数局部变量字段Function Var Item\n"
					+ "delfvi(del)-删除函数局部变量字段Function Var Item\n"
					+ "dc-退回到上一层";
				public static final String STFuncVarItem_HELP = "可用的命令：\n"
						+ "help-列出此帮助信息\n"
						+ "pwd-显示当前所处的场景\n"
						+ "whoami-显示当前操作的对象\n"
						+ "attr key value-修改当前对象的属性\n"
						+ "dc-退回到上一层";
		public static final String STVar_HELP = "可用的命令：\n"
				+ "help-列出此帮助信息\n"
				+ "pwd-显示当前所处的场景\n"
				+ "whoami-显示当前操作的对象\n"
				+ "attr key value-修改当前对象的属性\n"
				+ "lsvi(ls)-列出全局变量字段Var Item\n"
				+ "cdvi(cd)-进入全局变量字段Var Item\n"
				+ "addvi(add)-新增全局变量字段Var Item\n"
				+ "delvi(del)-删除全局变量字段Var Item\n"
				+ "dc-退回到上一层";
			public static final String STVarItem_HELP = "可用的命令：\n"
					+ "help-列出此帮助信息\n"
					+ "pwd-显示当前所处的场景\n"
					+ "whoami-显示当前操作的对象\n"
					+ "attr key value-修改当前对象的属性\n"
					+ "dc-退回到上一层";
	(2)	新增一个map，用于查询在不同的场景下应当显示什么帮助内容
	public static final Map<SceneType, String> mapHelpInfo = new HashMap<SceneType, String>(){{
			put(SceneType.STUser, STUser_HELP);
			put(SceneType.STStruct, STStruct_HELP);
			put(SceneType.STStructItem, STStructItem_HELP);
			put(SceneType.STType, STType_HELP);
			put(SceneType.STProject, STProject_HELP);
			put(SceneType.STFunc, STFunc_HELP);
			put(SceneType.STFuncStatement, STFuncStatement_HELP);
			put(SceneType.STFuncVar, STFuncVar_HELP);
			put(SceneType.STFuncVarItem, STFuncVarItem_HELP);
			put(SceneType.STVar, STVar_HELP);
			put(SceneType.STVarItem, STVarItem_HELP);
	}};
	
2.修改State类的定义，增加两项，分别是最近的用户输入，和最近给用户的输出。
	private String reqContent;
	private String respContent;
3.修改StateTransfer类
	（1）修改transferState()函数，在参数中，增加一项String reqContent，在调用
			nextState = func.apply(nowState,strArg1, strArg2);
		之前，增加对nowState的reqContent属性的设置
			nowState.setReqContent(reqContent);
	（2）注释掉构造函数public StateTransfer(State nowState)中2018-11-12和2018-11-11新增的所有内容
	（3）新增一个状态转移help
4.修改CoreServiceImplJHSBC
	（1）修改调用transferState（）函数的函数CoreServiceImp.StateProccedue()，传入reqContent参数
	（2）修改注释“进入状态机处理”处的代码，增加对StateProccedue的调用
4.修改FuncBase
	（1）将原有函数全部注释掉
	（2）根据场景枚举类型SeceneType中的注释，进行函数定义
	（3）并将attr、pwd、help、dc、whoami五个函数作为统一定义的函数
	（4）完成help函数，根据当前状态所属场景从Const类的mapHelpInfo中查找对应的help字符串，设置到当前状态state的的respContent中

2018-11-18
1.将StateService.java移入bk目录
2.修改CoreServiceImplJHSBC.java
	（1）进行stateTransfer的初始化，将
			//获取用户idUser成功后，如果是首次登录（状态栈为空），就记录到状态栈中,
    		if (stateStack.sizeof() == 0) {
    			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
    			stateStack.push(state);
    （2）将StateProccedue（）中的
    	    String strArg1 = strArray[1];
			String strArg2 = strArray[2];
    	改为
    		String strArg1 = (strArray.length>1?strArray[1]:null);
			String strArg2 = (strArray.length>2?strArray[2]:null);
3.修改StateTransfer.java
	（1）将transferState（）中的
		Func<State,String,String> func = stateMap.get(this.nowState).get(strOrder);
		改为
		Func<State,String,String> func = stateMap.get(this.nowState.getSceneType()).get(strOrder);  			
    		}

#commit #

2018-11-18/2
1.修改Func.java
	将
		public State apply(S s, T1 t1, T2 t2);
	改为
		public String apply(S s, T1 t1, T2 t2);
2.修改FuncBase.java
	将处理函数的形式由
		public static State del(State state, String str1, String str2) {
	改为
		public static String del(StateStack stateStack, String str1, String str2) {
3.删除移入bk的StateService.java和StateTransfer.java
4.新建一个StateService
	（1）将StateTransfer和StateStack作为它的成员变量
	（2）新建方法，根据用户名查询数据库是否有这个用户，对新用户做插表操作，并初始化stateStack和stateTransfer
			public String StateServiceOnUserLogin(String fromUserName) 
	（3）修改StateProccedue，直接从stateTransfer.transferState（）的返回值获取应当返回用户的提示语
5.修改StateTransfer
	（1）将
			Func<State,String,String>
		修改为
			Func<StateStack,String,String>
	（2）取消StateTransfer中的属性nowState
		取消构造函数中对nowState的初始化
	（3）取消transferState（）中对nowState中reqContent属性的设置，
		 //nowState.setReqContent(reqContent);
	（4）取消transferState（）中的状态转移操作
	（5）修改transferState（）的返回值为String
	（6）取消StateServiceOnUserLogin（）方法中“并用该状态初始化stateTransfer”的操作，改在StateService声明stateTransfer就进行初始化
	（7）初始化转移矩阵时
		1）取消transferMapSTUserPwd等
		2）将transferMapSTUserHelp改名为transferMapSTUser
		3）所有STUser状态下的转移都put到transferMapSTUser中，最后把transferMapSTUser加入stateMap
			//2018-11-18
			//初始化SceneType.STUser场景的转移出口，包括help、pwd********************
			HashMap<String, Func<StateStack,String,String> > transferMapSTUser = new HashMap<String, Func<StateStack,String,String>>();   
			//新增SceneType.STUser场景的转移出口help
			transferMapSTUser.put("help", FuncBase::help);
			//新增SceneType.STUser场景的转移出口help
			transferMapSTUser.put("pwd", FuncBase::pwd);
			//所有STUser状态下的转移都put到transferMapSTUser中，最后把transferMapSTUser加入stateMap
			stateMap.put(SceneType.STUser, transferMapSTUser);
6.修改CoreServiceImplJHSBC.java
	（1）新增成员stateService
	（2）取消成员stateTransfer和stateStack
	（3）取消直接处理
	/*   		//从数据库查询用户信息
	        	User user = null;
	        	user = db.getUserInfo(fromUserName);
	        	int idUser = 0;
	        	//如果没有查到就插入一条用户记录
	        	if (null == user) {
	        		User newUser = new User();
	        		newUser.setWeixinId_User(fromUserName);
	        		//int idUser = db.insertNewUser(newUser);
	        		db.insertNewUser(newUser);        		
	        		idUser  = newUser.getId_User();
	        		
	        	}else{//如果查询到就记录到状态栈中
	        		idUser = user.getId_User();    			
	        	}//if (null == user) 
	
	        	//如果查询idUser错误，或新增用户失败则返回
	        	if(0 == idUser)
	        		return "新增用户失败";
	        	     	
	    		//获取用户idUser成功后，如果是首次登录（状态栈为空），就记录到状态栈中，并用该状态初始化stateTransfer
	    		if (stateStack.sizeof() == 0) {
	    			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
	    			stateStack.push(state);
	    			
	    			stateTransfer = new StateTransfer(state);
	    			
	    		}
	        	        	
	        	//在返回语开头加上下文信息
	        	respContent = stateStack.getContext();*/
	    改为引用stateService类的方法StateServiceOnUserLogin（）
    		respContent = stateService.StateServiceOnUserLogin(fromUserName);
	（3）移除StateProccedue定义   
	（4）注释掉所有switch (reqContent)的内容 ,在对应未知加入
			// 如果是其它文本则进一步处理
			//进入状态机处理
			respContent = stateService.StateProccedue(reqContent);
    		System.out.println(respContent);
    		textMessage.setContent(respContent);
    		respMessage = textMessageUtil.messageToxml(textMessage);
    		return respMessage;
7.修改StateStack.java
	（1）将方法getCurrentState() 中的
			return stack[top];
		改为
			return stack[top-1]; 
			
#commit#
2018-11-18/3
1.修改CoreServiceImplJHSBC.java
	（1）由于不直接操作数据库，注释掉成员DbService db
			//数据库操作对象
			//private DbService db = new DbService();
2.修改FuncBase.java
	（1）新增DbService db
			//数据库操作对象
			private DbService db = new DbService();
	（2）修改现有的两个转移处理函数help和pwd，取消对state.respContent的写入
	（3）修改pwd，不使用stateStack.getContext();而使用stateStack.getPwd();
	（4）完善whoami
	（5）在转移表中增加TSUER场景的whoami操作
			//新增SceneType.STUser场景的转移出口whoami
			transferMapSTUser.put("whoami", FuncBase::whoami);	
	（6）将所有函数的2个字符串参数合并为1个
			String str1, String str2
			-》
			String str
	
3.修改State.java
	（1）取消两个成员
			//增加两项，分别是最近的用户输入，和最近给用户的输出
			//private String reqContent;
			//private String respContent;
4.修改StateStack.java
	（1）增加一个返回当前场景的函数
				public String getPwd()
5.修改StateService.java
	（1）修改StateProccedue()
			原来按空格分为多个子串，取前前三个作为transferState的输入，
		/*		String[] strArray = reqContent.split(" ");
				String strOrder = strArray[0];
				String strArg1 = (strArray.length>1?strArray[1]:null);
				String strArg2 = (strArray.length>2?strArray[2]:null);*/
			改为在第一个空格处将整个串分成两部分，第一部分作为命令，后一部分整体作为参数	
				String strOrder;
				String strArgs;
				int index = reqContent.indexOf(' ');
				if (index>0) {
					strOrder = reqContent.substring(0,reqContent.indexOf(' ')); 
					strArgs = reqContent.substring(reqContent.indexOf(' ')+1); // "tocirah sneab"
				}else {
					//用户只输入了单个词
					strOrder = reqContent;
				}
	（2）修改
			State state = new State(idUser,fromUserName,0,"用户:"+fromUserName,SceneType.STUser);
		为
			State state = new State(idUser,Const.tablename_User,0,"用户:"+fromUserName,SceneType.STUser);
6.修改StateTransfer.java
	（1）修改transferState（）的参数
		取消
			String reqContent
		将
			String strArg1, String strArg2
		合并为
			String strArgs
	（2）将
		Func<StateStack,String,String>
		改为
		Func<StateStack,String>
7.修改Func.java
	将
		public interface Func<S, T1, T2>
	改为
		public interface Func<S, T>	
8.新建一个scene_state包，把和状态、场景相关的类都放到这个包中
9.新写一个工具类DbCommonUtil.java。可以连接数据库，进行通用的增删改查操作，作为mybatis的互补。
10.修改Const.java
	（1）新增DbCommonUtil用来初始化数据库连接的
		//jdbc
		public static final String jdbcUrl = "jdbc:mysql://127.0.0.1:3306/java?useUnicode=true&characterEncoding=utf-8";
		//数据库用户名
		public static final String dbUser = "root";
		//数据库用户密码
		public static final String dbPwd = "pyt999";

		
2018-11-19
1.修改Const.java
	（1）新增各表名对应的id号
			public static final HashMap<String,String> mapTableId= new HashMap<String,String>(){{
				put(tablename_User,"Id_User");
					put(tablebame_Project,"Id_Project");
						put(tablebame_Function,"Id_Function");
							put(tablebame_FuncStatement,"Id_FuncStatement");
							put(tablebame_FuncVar,"Id_FuncVar");
								put(tablebame_FuncVarItem,"Id_FuncVarItem");
						put(tablebame_Var,"Id_Var");
							put(tablebame_VarItem,"Id_VarItem");
				put(tablebame_Struct,"Id_Struct");
					put(tablebame_StructItem,"Id_StructItem");
				put(tablebame_Type,"Id_Type");
			}
			};
	（2）新增数据库名
			public static final String dbSchema = "java";
			
2.修改FuncBase.java
	（1）修改whoami，输出每个字段的值
	（2）修改lsp
3.修改ProjectMapper.xml
	（1）增加
			<!-- 2018-11-19 自己加的 -->
			<select id="selectProjectsByUserId"
				parameterType="java.lang.String" resultMap="BaseResultMap">
				SELECT Project.*
				FROM User,Role,UserRoleRelation,Permission,RolePRMSRelation,Project
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
				AND User.Id_User =
				UserRoleRelation.Id_User
				AND UserRoleRelation.Id_Role = Role.Id_Role
				AND Role.Id_Role = RolePRMSRelation.Id_Role
				AND RolePRMSRelation.Id_Permission = Permission.Id_Permission
				AND Permission.Id_Project = Project.Id_Project
			</select>
4.修改ProjectMapper.java
	（1）增加
		 List<Project> selectProjectsByUserId(@Param("IdUser") int intUserId);
5.修改DbService.java
	（1）增加
		    public List<Project> getProjectsInfoByUserId(int intUserId) {
	        //public Project getProjectsInfo(String strWeixinId) {
	        	SqlSession session = sessionFactory.openSession();
	        	List<Project> projects = null;
	        	//Project projects = null;
	        	ProjectMapper mapper = session.getMapper(ProjectMapper.class);
	        	try {
	        		projects = mapper.selectProjectsByUserId(intUserId);
	        		session.commit();
	        	} catch (Exception e) {
	        		e.printStackTrace();
	        		session.rollback();
	        	}                 
	        	return projects;
	        }


2018-11-20
0.修改FuncBase.java
	（1）完善lss
	（2）完善lst
	（3）完善cdp
1.修改TypeMapper.xml
	（1）增加
		<select id="selectTypesByUserId"
			parameterType="java.lang.Integer" resultMap="BaseResultMap">
			SELECT Type.* FROM User,TypeUserRelation,Type
				WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
					AND User.Id_User = TypeUserRelation.Id_User
					AND TypeUserRelation.Id_Type = Type.Id_Type
	 	</select>
2.修改StructMapper.xml
	（1）增加
		  <!-- 2018-11-20 自己加的 -->
		  <select id="selectStructsByUserId"
				parameterType="java.lang.Integer" resultMap="BaseResultMap">
				SELECT Struct.* FROM User,StructUserRelation,Struct
					WHERE User.Id_User = #{IdUser,jdbcType=INTEGER}
						AND User.Id_User = StructUserRelation.Id_User
						AND StructUserRelation.Id_Struct = Struct.Id_Type
		  </select>
3.修改TypeMapper.java
	（1）增加
		 List<Type> selectTypesByUserId(@Param("IdUser") int intUserId);
4.修改StructMapper.java
	（1）增加
		 List<Struct> selectStructsByUserId(@Param("IdUser") int intUserId);
5.修改DbService.java
	（1）增加
		    public List<Type> getTypesInfoByUserId(int intUserId) {
	        
	        	SqlSession session = sessionFactory.openSession();
	        	List<Type> types = null;
	        	
	        	TypeMapper mapper = session.getMapper(TypeMapper.class);
	        	try {
	        		types = mapper.selectTypesByUserId(intUserId);
	        		session.commit();
	        	} catch (Exception e) {
	        		e.printStackTrace();
	        		session.rollback();
	        	}                 
	        	return types;
	    	}
    （2）增加
		    public List<Struct> getStructsInfoByUserId(int intUserId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	List<Struct> structs = null;
		    	
		    	StructMapper mapper = session.getMapper(StructMapper.class);
		    	try {
		    		structs = mapper.selectStructsByUserId(intUserId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return structs;
		    }
		        
    （3）增加
		    public Project getProjectByProjectId(int intProjectId) {
		      
		        	SqlSession session = sessionFactory.openSession();
		        	Project project = null;
		        	
		        	ProjectMapper mapper = session.getMapper(ProjectMapper.class);
		        	try {
		        		project = mapper.selectByPrimaryKey(intProjectId);
		        		session.commit();
		        	} catch (Exception e) {
		        		e.printStackTrace();
		        		session.rollback();
		        	}                 
		        	return project;
		    }
#未完成#6.写一个测试Core

2018-12-02（修改了数据库，经过mybatis自动对象的再次生成：run as-》mybatis generate）
0.修改数据库，在Type表上增加名字和注释两个字段
	ALTER TABLE `java`.`Type` 
		ADD COLUMN `Name_Type` VARCHAR(45) NULL AFTER `Id_NameSpace_Type`,
		ADD COLUMN `Memo_Type` VARCHAR(45) NULL AFTER `Name_Type`;
1.修改数据库后，重新执行工程右键-》run as mybatis generator。
	之后发现大部分之前的修改都在，包括添加的sql，但是调试发现新建工程的时候取不到新插入的project的id。发现问题在于之前的一处修改在重新调用mybastis generator的时候被改了回去
	重新进行修改
	（1）ProjectMapper.xml
	  	<insert id="insertSelective" parameterType="org.iscas.tj2.pyt.springboot_mybatis.domain.Project">
	  改为
		<insert id="insertSelective" parameterType="org.iscas.tj2.pyt.springboot_mybatis.domain.Project" useGeneratedKeys="true" keyProperty="idProject">
	（2）相应地修改所有.xml
2.修改FuncBase.java
	（1）完善addp
	（2）完善adds	
	（3）完善addt

3.修改StructMapper.xml
	（1）将
		AND StructUserRelation.Id_Struct = Struct.Id_Type
		改为
		AND StructUserRelation.Id_Struct = Struct.Id_Struct

4.修改DbService.java
	（1）增加getTypeByTypeId
		    public Type getTypeByTypeId(int intTypeId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	Type type = null;
		    	
		    	TypeMapper mapper = session.getMapper(TypeMapper.class);
		    	try {
		    		type = mapper.selectByPrimaryKey(intTypeId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return type;
		    }
    （2）增加getStructByStructId
		    public Struct getStructByStructId(int intStructId) {
		        
		    	SqlSession session = sessionFactory.openSession();
		    	Struct struct = null;
		    	
		    	StructMapper mapper = session.getMapper(StructMapper.class);
		    	try {
		    		struct = mapper.selectByPrimaryKey(intStructId);
		    		session.commit();
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return struct;
		    }

		        
    （3）增加
		    public int createStruct(int idUser,Struct struct) {
		    	SqlSession session = sessionFactory.openSession();
		    	int idStruct = 0;
		    	int idStructUserRelation = 0;
		
		    	StructMapper structMapper = session.getMapper(StructMapper.class);
		    	StructUserRelationMapper structUserRelationMapper = session.getMapper(StructUserRelationMapper.class);
		    	try {
		    		//插入Struct表
		    		structMapper.insertSelective(struct);
		    		idStruct = struct.getIdStruct();
		    		if (0 == idStruct) {
		    			return -1;
		    		}   		    		
		    		
		    		//插入StructUserRelation
		      		StructUserRelation structUserRelation = new StructUserRelation();
		    		structUserRelation.setIdStruct(idStruct);
		    		structUserRelation.setIdUser(idUser);
		    		structUserRelationMapper.insertSelective(structUserRelation);
		    		idStructUserRelation = structUserRelation.getIdStructuserrelation();
		    		if (0 == idStructUserRelation) {
		    			session.rollback();
		    			return -2;
		    		} 
		    		session.commit();
		    		
		    	} catch (Exception e) {
		    		e.printStackTrace();
		    		session.rollback();
		    	}                 
		    	return 0;
		    }   
		    
2018-12-03
1.修改FuncBase.java
	（1）完善cdp
	（2）完善cds	
	（3）完善cdt
	以上函数，均做如下修改
	（1）将
			db.getProjectByProjectId(state.getIntId())
		改为
			db.getStructByStructId(Integer.parseInt(str))
	（2）查询相应的dao对象后，先做是否为空的判断
		if (project/struct/type == null ) {
			return "cd失败，查询不到您指定的对象";			
		}
2.初始化SceneType.STProject场景的转移出口
3.为解决控制台警告信息
		Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
	在
